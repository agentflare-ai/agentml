---
title: "Error Handling"
description: "Best practices for handling errors in AgentML agents"
---

# Error Handling

Robust error handling is essential for production AgentML agents. SCXML's event-driven architecture provides natural patterns for graceful error handling.

## Error Events

SCXML defines standard error events that agents can handle:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript">

  <state id="processing">
    <onentry>
      <log expr="'Starting processing...'" />
    </onentry>

    <!-- Handle validation errors -->
    <transition event="error.execution" target="handle_error">
      <assign location="errorType" expr="'execution'" />
      <assign location="errorMessage" expr="_event.data.error" />
    </transition>

    <!-- Handle communication errors -->
    <transition event="error.communication" target="handle_error">
      <assign location="errorType" expr="'communication'" />
      <assign location="errorMessage" expr="_event.data.error" />
    </transition>
  </state>

  <state id="handle_error">
    <onentry>
      <log expr="'Error occurred: ' + errorType + ' - ' + errorMessage" />
    </onentry>

    <transition target="recovery" />
  </state>
</agent>
```

## Graceful Degradation

Handle errors gracefully without halting the agent:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript"
       xmlns:gemini="github.com/agentflare-ai/agentml/gemini"
       xmlns:ollama="github.com/agentflare-ai/agentml/ollama">

  <datamodel>
    <data id="retryCount" expr="0" />
    <data id="maxRetries" expr="3" />
  </datamodel>

  <state id="generate_primary">
    <onentry>
      <!-- Try primary provider (Gemini) -->
      <gemini:generate
        model="gemini-2.0-flash-exp"
        location="_event"
        promptexpr="userInput" />
    </onentry>

    <transition event="action.response" target="success">
      <assign location="response" expr="_event.data.message" />
    </transition>

    <!-- Fallback to local LLM on error -->
    <transition event="error.execution" target="generate_fallback">
      <log expr="'Primary provider failed, using fallback'" />
    </transition>
  </state>

  <state id="generate_fallback">
    <onentry>
      <!-- Use local Ollama as fallback -->
      <ollama:generate
        model="llama2"
        location="_event"
        promptexpr="userInput" />
    </onentry>

    <transition event="action.response" target="success">
      <assign location="response" expr="_event.data.message" />
    </transition>

    <transition event="error.execution" target="complete_failure">
      <log expr="'Both providers failed'" />
    </transition>
  </state>
</agent>
```

## Retry Logic with Exponential Backoff

Implement retry logic using state machines:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript"
       xmlns:gemini="github.com/agentflare-ai/agentml/gemini">

  <datamodel>
    <data id="retryCount" expr="0" />
    <data id="maxRetries" expr="3" />
    <data id="backoffMs" expr="1000" />
  </datamodel>

  <state id="attempt_processing">
    <onentry>
      <log expr="'Attempt ' + (retryCount + 1) + ' of ' + maxRetries" />

      <gemini:generate
        model="gemini-2.0-flash-exp"
        location="_event"
        promptexpr="userInput" />
    </onentry>

    <transition event="action.response" target="success">
      <assign location="response" expr="_event.data.message" />
    </transition>

    <!-- Retry on error if retries remaining -->
    <transition event="error.execution" cond="retryCount &lt; maxRetries" target="retry_delay">
      <assign location="retryCount" expr="retryCount + 1" />
      <assign location="backoffMs" expr="backoffMs * 2" />
      <log expr="'Retrying after ' + backoffMs + 'ms...'" />
    </transition>

    <!-- Give up after max retries -->
    <transition event="error.execution" target="max_retries_exceeded">
      <log expr="'Max retries exceeded'" />
    </transition>
  </state>

  <state id="retry_delay">
    <onentry>
      <!-- Send delayed retry event -->
      <send event="retry" delayexpr="backoffMs + 'ms'" />
    </onentry>

    <transition event="retry" target="attempt_processing" />
  </state>
</agent>
```

## Validation with JSON Schema

Validate LLM outputs using `event:schema`:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript"
       xmlns:gemini="github.com/agentflare-ai/agentml/gemini">

  <state id="request_booking">
    <onentry>
      <gemini:generate
        model="gemini-2.0-flash-exp"
        location="_event"
        promptexpr="'Extract booking details: ' + userInput" />
    </onentry>

    <!-- Valid response matching schema -->
    <transition
      event="action.response"
      event:schema='{
        "type": "object",
        "properties": {
          "from": {"type": "string"},
          "to": {"type": "string"},
          "date": {"type": "string", "format": "date"}
        },
        "required": ["from", "to", "date"]
      }'
      target="process_booking">
      <assign location="booking" expr="_event.data" />
    </transition>

    <!-- Invalid response - retry -->
    <transition event="action.response" target="request_booking">
      <log expr="'Invalid booking format, retrying...'" />
    </transition>

    <transition event="error.execution" target="handle_error" />
  </state>

  <state id="handle_error">
    <onentry>
      <log expr="'Booking extraction failed: ' + _event.data.error" />
    </onentry>
    <transition target="final" />
  </state>
</agent>
```

## Circuit Breaker Pattern

Prevent cascading failures using parallel states:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript"
       xmlns:gemini="github.com/agentflare-ai/agentml/gemini">

  <datamodel>
    <data id="failureCount" expr="0" />
    <data id="lastFailureTime" expr="0" />
    <data id="circuitThreshold" expr="5" />
    <data id="circuitTimeoutMs" expr="60000" />
  </datamodel>

  <parallel id="main">
    <!-- Circuit breaker monitor -->
    <state id="circuit_monitor">
      <state id="circuit_closed">
        <transition cond="failureCount >= circuitThreshold" target="circuit_open">
          <assign location="lastFailureTime" expr="Date.now()" />
          <log expr="'Circuit breaker opened'" />
        </transition>
      </state>

      <state id="circuit_open">
        <transition cond="(Date.now() - lastFailureTime) > circuitTimeoutMs" target="circuit_half_open">
          <log expr="'Circuit breaker half-open, testing...'" />
        </transition>
      </state>

      <state id="circuit_half_open">
        <transition event="request.success" target="circuit_closed">
          <assign location="failureCount" expr="0" />
          <log expr="'Circuit breaker closed'" />
        </transition>

        <transition event="request.failure" target="circuit_open">
          <assign location="lastFailureTime" expr="Date.now()" />
        </transition>
      </state>
    </state>

    <!-- Request processor -->
    <state id="request_processor">
      <state id="idle">
        <transition event="user.request" cond="In('circuit_closed') || In('circuit_half_open')" target="processing">
          <assign location="userInput" expr="_event.data.message" />
        </transition>

        <transition event="user.request" target="circuit_blocked">
          <log expr="'Request blocked: circuit breaker open'" />
        </transition>
      </state>

      <state id="processing">
        <onentry>
          <gemini:generate
            model="gemini-2.0-flash-exp"
            location="_event"
            promptexpr="userInput" />
        </onentry>

        <transition event="action.response" target="idle">
          <raise event="request.success" />
          <assign location="response" expr="_event.data.message" />
        </transition>

        <transition event="error.execution" target="idle">
          <raise event="request.failure" />
          <assign location="failureCount" expr="failureCount + 1" />
        </transition>
      </state>

      <state id="circuit_blocked">
        <onentry>
          <log expr="'Service unavailable: circuit breaker open'" />
        </onentry>
        <transition target="idle" />
      </state>
    </state>
  </parallel>
</agent>
```

## Logging Best Practices

Use `<log>` for debugging and monitoring:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript"
       xmlns:gemini="github.com/agentflare-ai/agentml/gemini">

  <state id="processing">
    <onentry>
      <!-- Log entry with context -->
      <log expr="'[' + Date.now() + '] Entering state: processing'" />
      <log expr="'Input: ' + JSON.stringify(userInput)" />

      <gemini:generate
        model="gemini-2.0-flash-exp"
        location="_event"
        promptexpr="userInput" />
    </onentry>

    <transition event="action.response" target="complete">
      <log expr="'[' + Date.now() + '] Processing completed successfully'" />
      <log expr="'Tokens used: ' + _event.data.usage.totalTokens" />
      <assign location="response" expr="_event.data.message" />
    </transition>

    <transition event="error.execution" target="handle_error">
      <log expr="'[' + Date.now() + '] ERROR: ' + _event.data.error" />
      <log expr="'Stack: ' + _event.data.stack" />
      <log expr="'Datamodel state: ' + JSON.stringify({userInput, retryCount})" />
    </transition>
  </state>
</agent>
```

## Error Context

Capture error context for debugging:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript">

  <datamodel>
    <data id="errorLog" expr="[]" />
  </datamodel>

  <state id="processing">
    <transition event="error.execution" target="handle_error">
      <!-- Capture full error context -->
      <assign location="errorLog" expr="errorLog.concat([{
        timestamp: Date.now(),
        state: 'processing',
        error: _event.data.error,
        code: _event.data.code,
        datamodel: {
          userInput: userInput,
          retryCount: retryCount
        }
      }])" />
    </transition>
  </state>

  <state id="handle_error">
    <onentry>
      <log expr="'Error log: ' + JSON.stringify(errorLog, null, 2)" />
    </onentry>

    <transition cond="retryCount &lt; 3" target="retry">
      <assign location="retryCount" expr="retryCount + 1" />
    </transition>

    <transition target="final" />
  </state>
</agent>
```

## Monitoring and Observability

Monitor agent health in production:

```bash
# View agent logs
agentmlx run agent.aml 2>&1 | tee agent.log

# Monitor with systemd
sudo journalctl -u agentml-agent -f

# Check agent status
agentmlx validate agent.aml
```

Use structured logging for analysis:

```xml
<state id="processing">
  <onentry>
    <!-- Structured log for parsing -->
    <log expr="JSON.stringify({
      level: 'info',
      event: 'processing_started',
      timestamp: Date.now(),
      state: 'processing',
      input_length: userInput.length
    })" />
  </onentry>
</state>
```

## Best Practices

1. **Use error events**: Handle `error.execution` and `error.communication` events
2. **Validate inputs**: Use JSON Schema with `event:schema` attribute
3. **Implement fallbacks**: Gracefully degrade to alternative providers
4. **Retry with backoff**: Use exponential backoff for transient failures
5. **Circuit breakers**: Prevent cascading failures with circuit breaker pattern
6. **Log comprehensively**: Include context, timestamps, and datamodel state
7. **Capture error context**: Store error details for debugging
8. **Monitor in production**: Use systemd journald or log aggregation
9. **Test error paths**: Ensure error handling works as expected
10. **Document error states**: Clearly document error recovery paths

## Next Steps

- Learn about [Testing](/best-practices/testing) strategies for agents
- Read [Performance](/best-practices/performance) optimization techniques
- Explore [State Machines](/concepts/state-machines) for robust control flow
- See [Event-Driven LLM](/concepts/event-driven-llm) for event patterns
