---
title: "Namespaces"
description: "Extend AgentML functionality with namespaces using the xmlns:prefix directive"
---

# Namespaces

Namespaces are the primary way to extend AgentML functionality. They provide modular, reusable components for LLM integration, memory, I/O, and custom functionality.

## What Are Namespaces?

Namespaces extend the SCXML vocabulary with custom actions and elements. In AgentML, namespaces are declared using the `xmlns:prefix="uri"` directive on the `<agent>` root element.

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript"
       xmlns:gemini="github.com/agentflare-ai/agentml/gemini"
       xmlns:memory="github.com/agentflare-ai/agentml/memory">

  <state id="processing">
    <onentry>
      <!-- Use Gemini namespace -->
      <gemini:generate
        model="gemini-2.0-flash-exp"
        location="_event"
        promptexpr="'Process this: ' + userInput" />

      <!-- Use Memory namespace -->
      <memory:put key="last_input" expr="userInput" />
    </onentry>
  </state>
</agent>
```

## Built-in Namespaces

AgentML provides several built-in namespaces:

### Agent Namespace

The core namespace for AgentML-specific features (default namespace):

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript">

  <!-- event:schema is from the agent namespace -->
  <transition event="user.message"
              event:schema='{"type": "object", "properties": {"message": {"type": "string"}}}'
              target="processing" />
</agent>
```

### Gemini Namespace

Google Gemini LLM integration:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       xmlns:gemini="github.com/agentflare-ai/agentml/gemini">

  <state id="generate">
    <onentry>
      <gemini:generate
        model="gemini-2.0-flash-exp"
        location="_event"
        promptexpr="'You are a helpful assistant. ' + userInput" />
    </onentry>

    <transition event="action.response" target="process_response" />
  </state>
</agent>
```

### Ollama Namespace

Local LLM integration via Ollama:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       xmlns:ollama="github.com/agentflare-ai/agentml/ollama">

  <state id="generate">
    <onentry>
      <ollama:generate
        model="llama2"
        location="_event"
        promptexpr="userInput" />
    </onentry>
  </state>
</agent>
```

### Memory Namespace

High-performance memory with vector search and graph database:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       xmlns:memory="github.com/agentflare-ai/agentml/memory">

  <state id="store_data">
    <onentry>
      <!-- Vector embedding -->
      <memory:embed location="embedding" expr="textContent" />

      <!-- Key-value storage -->
      <memory:put key="user_preference" expr="preferenceValue" />

      <!-- Graph query -->
      <memory:graph-query location="results">
        <query>
          MATCH (p:Person)-[:KNOWS]->(friend)
          WHERE p.age > 25
          RETURN p.name, friend.name
        </query>
      </memory:graph-query>

      <!-- Vector search -->
      <memory:search location="results" expr="queryEmbedding" limit="10" />
    </onentry>
  </state>
</agent>
```

The memory namespace is powered by `sqlite-graph`, providing:
- Vector similarity search
- Graph database with Cypher queries
- Embedding generation
- Persistent key-value storage
- All in a single SQLite file

### Stdin Namespace

Simple stdin/stdout I/O for console agents:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       xmlns:stdin="github.com/agentflare-ai/agentml/stdin">

  <state id="get_input">
    <onentry>
      <stdin:read location="userInput" />
    </onentry>

    <transition event="stdin.received" target="process" />
  </state>

  <state id="output">
    <onentry>
      <stdin:write expr="response" />
    </onentry>
  </state>
</agent>
```

## Importing Namespaces

### Basic Import

Use the `xmlns:prefix="uri"` attribute:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       xmlns:gemini="github.com/agentflare-ai/agentml/gemini">
  <!-- gemini:generate is now available -->
</agent>
```

### Multiple Imports

Import multiple namespaces:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       xmlns:gemini="github.com/agentflare-ai/agentml/gemini"
       xmlns:ollama="github.com/agentflare-ai/agentml/ollama"
       xmlns:memory="github.com/agentflare-ai/agentml/memory"
       xmlns:stdin="github.com/agentflare-ai/agentml/stdin">

  <state id="multi_namespace">
    <onentry>
      <gemini:generate model="gemini-2.0-flash-exp" location="_event" promptexpr="'Hello'" />
      <memory:put key="test" expr="'value'" />
      <stdin:write expr="'Output'" />
    </onentry>
  </state>
</agent>
```

### External Schema Import

Import JSON/YAML files for schemas:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       xmlns:events="./schemas/events.json"
       xmlns:api="./schemas/openapi.yaml">

  <!-- Reference schemas with JSON Pointer -->
  <transition event="user.message"
              event:schema="events:#/components/schemas/UserMessage"
              target="processing" />
</agent>
```

## Creating Custom Namespaces

### Go Implementation (Current)

Currently, custom namespaces are implemented in Go. Here's a basic structure:

**namespace.go:**
```go
package customnamespace

import (
    "github.com/agentflare-ai/agentmlx/pkg/scxml"
)

type CustomAction struct {
    Model    string `xml:"model,attr"`
    Location string `xml:"location,attr"`
    Prompt   string `xml:"prompt,attr"`
}

func (a *CustomAction) Execute(ctx *scxml.Context) error {
    // Implementation here
    result := processPrompt(a.Prompt, a.Model)
    ctx.SetVariable(a.Location, result)
    return nil
}

func Register() {
    scxml.RegisterNamespace("github.com/example/custom", map[string]interface{}{
        "process": &CustomAction{},
    })
}
```

**Usage:**
```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       xmlns:custom="github.com/example/custom">

  <state id="use_custom">
    <onentry>
      <custom:process model="mymodel" location="result" prompt="Hello" />
    </onentry>
  </state>
</agent>
```

### WASM Implementation (Planned)

Future: Implement namespaces in any language via WebAssembly:

**agentml.wit:**
```wit
package agentml:core

interface namespace {
    record action-params {
        name: string,
        attributes: list<tuple<string, string>>,
        content: string,
    }

    record action-result {
        success: bool,
        data: option<string>,
        error: option<string>,
    }

    execute-action: func(params: action-params) -> action-result
}
```

**Rust implementation:**
```rust
wit_bindgen::generate!({
    path: "agentml.wit",
});

struct MyNamespace;

impl Namespace for MyNamespace {
    fn execute_action(params: ActionParams) -> ActionResult {
        // Process action
        ActionResult {
            success: true,
            data: Some("result".to_string()),
            error: None,
        }
    }
}
```

**Usage:**
```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       xmlns:custom="https://cdn.example.com/custom-namespace.wasm">

  <state id="use_wasm">
    <onentry>
      <custom:action attr="value" />
    </onentry>
  </state>
</agent>
```

## Namespace Patterns

### LLM Integration Pattern

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       xmlns:gemini="github.com/agentflare-ai/agentml/gemini">

  <datamodel>
    <data id="userInput" expr="''" />
    <data id="llmResponse" expr="''" />
  </datamodel>

  <state id="process">
    <onentry>
      <gemini:generate
        model="gemini-2.0-flash-exp"
        location="_event"
        promptexpr="'Process: ' + userInput" />
    </onentry>

    <transition event="action.response" target="handle_response">
      <assign location="llmResponse" expr="_event.data.message" />
    </transition>

    <transition event="action.error" target="handle_error" />
  </state>
</agent>
```

### Memory Persistence Pattern

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       xmlns:memory="github.com/agentflare-ai/agentml/memory">

  <state id="save_state">
    <onentry>
      <!-- Save to memory -->
      <memory:put key="conversation_state" expr="currentState" />
      <memory:put key="user_context" expr="userContext" />
    </onentry>
  </state>

  <state id="restore_state">
    <onentry>
      <!-- Restore from memory -->
      <memory:get key="conversation_state" location="currentState" />
      <memory:get key="user_context" location="userContext" />
    </onentry>
  </state>
</agent>
```

### Multi-Provider Pattern

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       xmlns:gemini="github.com/agentflare-ai/agentml/gemini"
       xmlns:ollama="github.com/agentflare-ai/agentml/ollama">

  <state id="classify">
    <!-- Use fast local model for classification -->
    <onentry>
      <ollama:generate
        model="llama2"
        location="_event"
        promptexpr="'Classify: ' + userInput" />
    </onentry>

    <transition event="action.response" target="generate" />
  </state>

  <state id="generate">
    <!-- Use powerful cloud model for generation -->
    <onentry>
      <gemini:generate
        model="gemini-2.0-flash-exp"
        location="_event"
        promptexpr="'Generate response for: ' + classification" />
    </onentry>
  </state>
</agent>
```

## Best Practices

1. **Use specific namespace URIs**: `github.com/org/project/namespace` not just `custom`
2. **Document your namespace**: Provide clear usage examples
3. **Version your namespace**: Include version in URI if needed
4. **Handle errors**: Emit error events for failure cases
5. **Follow SCXML conventions**: Use standard SCXML patterns
6. **Test thoroughly**: Unit test namespace actions
7. **Provide schemas**: Document expected data structures
8. **Keep actions focused**: One action should do one thing
9. **Use standard attributes**: Follow `location`, `expr`, etc. conventions
10. **Plan for WASM**: Design with future WASM migration in mind

## Namespace Registry (Planned)

Future: Centralized registry for discovering and installing namespaces:

```bash
# Search for namespaces
agentmlx namespace search stripe

# Install namespace
agentmlx namespace install github.com/community/stripe

# List installed namespaces
agentmlx namespace list

# Update namespace
agentmlx namespace update github.com/community/stripe
```

## Next Steps

- Learn about [Custom Extensions](/extensions/custom) for detailed implementation
- Explore [Memory Extension](/extensions/memory) for vector search and graphs
- See [Gemini Extension](/extensions/gemini) for LLM integration examples
- Read [Document Structure](/architecture/document-structure) for namespace syntax
- Understand [Namespace System](/architecture/namespace-system) architecture
