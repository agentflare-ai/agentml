---

title: "Event-Driven LLM Architecture"
description: "Understanding the event-driven approach to LLM interactions in AgentML"
---

# Event-Driven LLM Architecture

AgentML uses an event-driven architecture based on W3C SCXML to manage LLM interactions, providing deterministic control, complete observability, and formal verifiability.

## Why Event-Driven?

Traditional LLM integrations rely on simple function calls or streaming responses, making it difficult to:

* **Control execution flow**: Hard to pause, resume, or cancel operations
* **Ensure determinism**: Same inputs don't guarantee same state transitions
* **Audit behavior**: Limited visibility into decision-making process
* **Compose workflows**: Difficult to build complex multi-step interactions
* **Handle errors gracefully**: No formal error recovery patterns

AgentML solves these problems by treating every LLM interaction as part of a formal state machine.

## Benefits

**Deterministic Execution**

* State transitions are explicit and predictable
* Same inputs always produce same state paths
* Formal verification of agent behavior possible

**Complete Observability**

* Every event is traceable through the state machine
* OpenTelemetry tracing built-in
* Runtime snapshots capture complete agent state

**Better Control**

* Pause, resume, or cancel at any state
* Implement timeouts and retry logic declaratively
* Handle errors with explicit error states

**Composability**

* Build complex agents from simpler state machines
* Reuse common patterns across agents
* Invoke sub-agents as services with `<invoke>`

## Event Flow in AgentML

Events flow through the SCXML state machine, triggering transitions and executing actions:

```xml
<agentml xmlns="github.com/agentflare-ai/agentml"
       datamodel="ecmascript"
       xmlns:openai="github.com/agentflare-ai/agentml-go/openai">

  <datamodel>
    <data id="user_input" expr="''" />
  </datamodel>

  <!-- Event arrives: user.message -->
  <state id="idle">
    <transition event="user.message" target="processing">
      <assign location="user_input" expr="_event.data.message" />
    </transition>
  </state>

  <!-- Process with LLM -->
  <state id="processing">
    <onentry>
      <openai:generate
        model="gpt-4o"
        location="_event"
        promptexpr="'Help the user: ' + user_input" />
    </onentry>

    <!-- Event arrives: action.response -->
    <transition event="action.response" target="responding" />
  </state>

  <state id="responding">
    <onentry>
      <log expr="'Response: ' + _event.data.message" />
    </onentry>
    <transition target="idle" />
  </state>
</agentml>
```

## Event Types in AgentML

### User Events

Events from external sources (HTTP, WebSocket, stdin):

```xml
<transition event="user.message" target="processing" />
<transition event="user.query" target="search" />
<transition event="user.cancel" target="cancelled" />
```

### LLM Events

Events generated by LLM namespace actions:

```xml
<transition event="action.response" target="handle_response" />
<transition event="action.error" target="handle_error" />
```

### System Events

Built-in SCXML events:

```xml
<!-- Raised when entering a final state -->
<transition event="done.state.substatemachine" target="next_step" />

<!-- Raised on errors -->
<transition event="error.execution" target="error_handler" />
```

### Custom Events

Raise custom events with `<raise>`:

```xml
<state id="validate">
  <onentry>
    <if cond="user_input.length > 0">
      <raise event="validation.success" />
    <else/>
      <raise event="validation.failed" />
    </if>
  </onentry>

  <transition event="validation.success" target="process" />
  <transition event="validation.failed" target="request_input" />
</state>
```

## Event Naming Conventions

Use dot-separated namespaces for event names:

```xml
<!-- Good: Hierarchical event names -->
<transition event="user.message.text" />
<transition event="user.message" />  <!-- Matches user.message.* -->
<transition event="llm.response.complete" />
<transition event="error.network.timeout" />

<!-- Avoid: Flat event names -->
<transition event="message" />  <!-- Too generic -->
<transition event="done" />     <!-- Ambiguous -->
```

Event matching in SCXML supports wildcards:

* `user.message` matches `user.message`, `user.message.text`, `user.message.voice`
* `user.message.text` only matches exactly `user.message.text`

## Schema-Guided Events

The `schema` attribute validates events against JSON Schema, ensuring type safety:

```xml
<transition event="intent.flight"
            schema='{
              "type": "object",
              "description": "Flight booking intent from user",
              "properties": {
                "action": {
                  "type": "string",
                  "enum": ["search", "book", "cancel"],
                  "description": "The flight action to perform"
                },
                "from": {
                  "type": "string",
                  "description": "Departure city or airport code"
                },
                "to": {
                  "type": "string",
                  "description": "Arrival city or airport code"
                },
                "date": {
                  "type": "string",
                  "format": "date",
                  "description": "Departure date in YYYY-MM-DD format"
                }
              },
              "required": ["action"]
            }'
            target="handle_flight">
  <assign location="flight_request" expr="_event.data" />
</transition>
```

**Important**: Always include `description` fields at both the schema and property level. These descriptions guide the LLM in generating correctly structured events.

## External Schema References

For better maintainability, define schemas in external files:

**schemas/events.json:**

```json
{
  "components": {
    "schemas": {
      "FlightIntent": {
        "type": "object",
        "description": "Flight booking intent",
        "properties": {
          "action": {
            "type": "string",
            "enum": ["search", "book", "cancel"],
            "description": "The flight action"
          }
        }
      }
    }
  }
}
```

**agent.aml:**

```xml
<agentml xmlns="github.com/agentflare-ai/agentml"
       xmlns:events="./schemas/events.json">

  <transition event="intent.flight"
              schema="events:#/components/schemas/FlightIntent"
              target="handle_flight" />
</agentml>
```

## Event Data Access

Access event data through the `_event` system variable:

```xml
<state id="process">
  <onentry>
    <!-- Access event type -->
    <log expr="'Event: ' + _event.name" />

    <!-- Access event data -->
    <log expr="'Message: ' + _event.data.message" />

    <!-- Access event origin -->
    <log expr="'From: ' + _event.origin" />

    <!-- Store event data in datamodel -->
    <assign location="last_message" expr="_event.data.message" />
  </onentry>
</state>
```

## External Communications

AgentML supports distributed event communication via IOProcessors:

```xml
<state id="notify_remote">
  <onentry>
    <!-- Send event to remote agent via HTTP -->
    <send event="task.assigned"
          target="https://agent.example.com/events"
          type="github.com/agentflare-ai/agentml/ioprocessor/http">
      <param name="task_id" expr="current_task.id" />
      <param name="priority" expr="'high'" />
    </send>
  </onentry>

  <!-- Wait for acknowledgment -->
  <transition event="task.acknowledged" target="confirmed" />
  <transition event="error.communication" target="retry">
    <after delay="5s" />
  </transition>
</state>
```

See [I/O Processors](/architecture/io-processors) for more details.

## Error Handling

Handle errors with explicit error states and events:

```xml
<state id="processing">
  <onentry>
    <openai:generate
      model="gpt-4o"
      location="_event"
      promptexpr="user_input" />
  </onentry>

  <!-- Success path -->
  <transition event="action.response" target="responding" />

  <!-- Error paths -->
  <transition event="action.error" cond="_event.data.type === 'rate_limit'" target="rate_limited" />
  <transition event="action.error" cond="_event.data.type === 'timeout'" target="timeout" />
  <transition event="action.error" target="general_error" />
</state>

<state id="rate_limited">
  <onentry>
    <log expr="'Rate limited, retrying in 60s'" />
  </onentry>
  <transition target="processing">
    <after delay="60s" />
  </transition>
</state>

<state id="timeout">
  <onentry>
    <log expr="'Request timed out, retrying'" />
  </onentry>
  <transition target="processing" />
</state>

<state id="general_error">
  <onentry>
    <log expr="'Error: ' + _event.data.message" />
  </onentry>
  <transition target="idle" />
</state>
```

## Best Practices

1. **Use hierarchical event names**: `user.message.text` instead of `message`
2. **Always provide schemas**: Use `schema` for type safety
3. **Include descriptions**: Guide LLMs with detailed schema descriptions
4. **Handle all events**: Provide fallback transitions for unexpected events
5. **Keep states focused**: Each state should have a single responsibility
6. **Use external schemas**: Define schemas in separate files for reuse
7. **Log state transitions**: Use `<log>` for debugging and observability
8. **Implement error states**: Explicitly handle all error conditions

## Next Steps

* Learn about [State Machines](/concepts/state-machines) for building complex workflows
* Explore [Events & Schemas](/concepts/events-schemas) for data validation
* Understand [Token Efficiency](/concepts/token-efficiency) for optimizing costs
* Read about [Namespaces](/concepts/namespaces) for extending functionality
