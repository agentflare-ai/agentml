---
title: "Events & Schemas"
description: "Structure your data with event:schema validation for type-safe AgentML agents"
---

# Events & Schemas

AgentML uses JSON Schema to validate events, ensuring type safety and guiding LLMs to generate correctly structured data. The `event:schema` attribute is a key feature that makes agents reliable and predictable.

## Understanding Events in AgentML

Events are the primary communication mechanism in W3C SCXML state machines. In AgentML, events trigger state transitions and carry data payloads.

### Event Structure

Every event has:
- **Name**: Dot-separated hierarchical identifier (e.g., `user.message.text`)
- **Data**: JSON payload with the event's information
- **Origin**: Source of the event (IOProcessor, internal raise, etc.)

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript">

  <state id="idle">
    <!-- Event: user.message -->
    <!-- Data: { message: "Hello", userId: "user123" } -->
    <transition event="user.message" target="processing">
      <assign location="userInput" expr="_event.data.message" />
      <assign location="userId" expr="_event.data.userId" />
    </transition>
  </state>
</agent>
```

### Event Naming Conventions

Use dot-separated namespaces for hierarchical organization:

```xml
<!-- Good: Hierarchical, specific -->
<transition event="user.message.text" target="handle_text" />
<transition event="user.message.voice" target="handle_voice" />
<transition event="llm.response.complete" target="process_response" />
<transition event="error.network.timeout" target="retry" />

<!-- Avoid: Flat, ambiguous -->
<transition event="message" target="handle" />
<transition event="done" target="next" />
```

Event matching supports wildcards:
- `user.message` matches `user.message`, `user.message.text`, `user.message.voice`
- `user.message.text` matches only `user.message.text`

## Schema-Guided Events

The `event:schema` attribute validates events against JSON Schema, providing:

- **Type Safety**: Ensure data has correct types
- **LLM Guidance**: Descriptions guide LLM output generation
- **Runtime Validation**: Catch errors before they propagate
- **Documentation**: Schemas document expected data structure

### Basic Schema Validation

```xml
<transition event="intent.greeting"
            event:schema='{
              "type": "object",
              "description": "Greeting intent from user",
              "properties": {
                "greeting_type": {
                  "type": "string",
                  "enum": ["hello", "hi", "hey"],
                  "description": "Type of greeting"
                },
                "formality": {
                  "type": "string",
                  "enum": ["casual", "formal"],
                  "description": "Formality level"
                }
              },
              "required": ["greeting_type"]
            }'
            target="respond_greeting" />
```

### Complete Schema Example

```xml
<transition event="intent.flight"
            event:schema='{
              "type": "object",
              "description": "Flight booking intent extracted from user message",
              "properties": {
                "action": {
                  "type": "string",
                  "enum": ["search", "book", "cancel", "modify"],
                  "description": "The flight action to perform"
                },
                "departure": {
                  "type": "object",
                  "description": "Departure information",
                  "properties": {
                    "location": {
                      "type": "string",
                      "description": "Departure city or airport code (e.g., SFO, New York)"
                    },
                    "date": {
                      "type": "string",
                      "format": "date",
                      "description": "Departure date in YYYY-MM-DD format"
                    },
                    "time": {
                      "type": "string",
                      "description": "Preferred departure time (e.g., morning, 2pm, evening)"
                    }
                  },
                  "required": ["location", "date"]
                },
                "arrival": {
                  "type": "object",
                  "description": "Arrival information",
                  "properties": {
                    "location": {
                      "type": "string",
                      "description": "Arrival city or airport code"
                    }
                  },
                  "required": ["location"]
                },
                "passengers": {
                  "type": "number",
                  "minimum": 1,
                  "description": "Number of passengers"
                },
                "class": {
                  "type": "string",
                  "enum": ["economy", "business", "first"],
                  "description": "Cabin class preference"
                }
              },
              "required": ["action", "departure", "arrival"]
            }'
            target="handle_flight" />
```

**Critical**: Always include `description` fields at both schema and property levels. These descriptions are the primary mechanism for guiding LLMs.

## External Schema Files

For maintainability, define schemas in separate JSON or YAML files:

### JSON Schema File

**schemas/events.json:**
```json
{
  "components": {
    "schemas": {
      "FlightIntent": {
        "type": "object",
        "description": "Flight booking intent from user",
        "properties": {
          "action": {
            "type": "string",
            "enum": ["search", "book", "cancel"],
            "description": "The flight action to perform"
          },
          "from": {
            "type": "string",
            "description": "Departure location"
          },
          "to": {
            "type": "string",
            "description": "Arrival location"
          }
        },
        "required": ["action", "from", "to"]
      },
      "GreetingIntent": {
        "type": "object",
        "description": "Greeting from user",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["hello", "goodbye"],
            "description": "Greeting type"
          }
        },
        "required": ["type"]
      }
    }
  }
}
```

### Using External Schemas

Reference external schemas with JSON Pointer (RFC 6901):

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript"
       xmlns:events="./schemas/events.json">

  <state id="classify_intent">
    <!-- Reference using namespace:pointer syntax -->
    <transition event="intent.flight"
                event:schema="events:#/components/schemas/FlightIntent"
                target="handle_flight" />

    <transition event="intent.greeting"
                event:schema="events:#/components/schemas/GreetingIntent"
                target="handle_greeting" />
  </state>
</agent>
```

### OpenAPI Schemas

You can also import OpenAPI specifications:

**schemas/api.yaml:**
```yaml
openapi: 3.0.0
components:
  schemas:
    UserMessage:
      type: object
      description: User message payload
      properties:
        message:
          type: string
          description: The message text
        userId:
          type: string
          description: User identifier
      required:
        - message
        - userId
```

**agent.aml:**
```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       xmlns:api="./schemas/api.yaml">

  <transition event="user.message"
              event:schema="api:#/components/schemas/UserMessage"
              target="processing" />
</agent>
```

## Accessing Event Data

Use the `_event` system variable to access event data:

```xml
<state id="process">
  <onentry>
    <!-- Access event name -->
    <log expr="'Event type: ' + _event.name" />

    <!-- Access event data -->
    <assign location="message" expr="_event.data.message" />
    <assign location="userId" expr="_event.data.userId" />

    <!-- Access origin -->
    <log expr="'Event from: ' + _event.origin" />

    <!-- Access nested properties -->
    <assign location="departure" expr="_event.data.flight.departure" />
  </onentry>
</state>
```

## Schema Validation Patterns

### Required vs Optional Fields

```xml
<transition event="user.profile"
            event:schema='{
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "User full name (required)"
                },
                "email": {
                  "type": "string",
                  "format": "email",
                  "description": "User email address (required)"
                },
                "phone": {
                  "type": "string",
                  "description": "Phone number (optional)"
                },
                "age": {
                  "type": "number",
                  "minimum": 0,
                  "description": "User age (optional)"
                }
              },
              "required": ["name", "email"]
            }'
            target="process_profile" />
```

### Array Validation

```xml
<transition event="order.items"
            event:schema='{
              "type": "object",
              "properties": {
                "items": {
                  "type": "array",
                  "description": "List of items in order",
                  "items": {
                    "type": "object",
                    "properties": {
                      "productId": {
                        "type": "string",
                        "description": "Product identifier"
                      },
                      "quantity": {
                        "type": "number",
                        "minimum": 1,
                        "description": "Quantity ordered"
                      }
                    },
                    "required": ["productId", "quantity"]
                  },
                  "minItems": 1
                }
              },
              "required": ["items"]
            }'
            target="process_order" />
```

### Enum Constraints

```xml
<transition event="status.update"
            event:schema='{
              "type": "object",
              "properties": {
                "status": {
                  "type": "string",
                  "enum": ["pending", "processing", "completed", "failed"],
                  "description": "Current status of the task"
                },
                "priority": {
                  "type": "string",
                  "enum": ["low", "medium", "high", "urgent"],
                  "description": "Task priority level"
                }
              },
              "required": ["status"]
            }'
            target="update_status" />
```

## Raising Events

Generate events internally with `<raise>`:

```xml
<state id="validate">
  <onentry>
    <if cond="userInput.length > 0">
      <raise event="validation.success">
        <param name="input" expr="userInput" />
      </raise>
    <else/>
      <raise event="validation.failed">
        <param name="error" expr="'Input cannot be empty'" />
      </raise>
    </if>
  </onentry>

  <transition event="validation.success" target="process" />
  <transition event="validation.failed" target="request_input" />
</state>
```

## Sending External Events

Send events to external systems with `<send>`:

```xml
<state id="notify">
  <onentry>
    <send event="task.assigned"
          target="https://api.example.com/webhooks"
          type="github.com/agentflare-ai/agentml/ioprocessor/http">
      <param name="taskId" expr="currentTask.id" />
      <param name="assignee" expr="currentTask.assignee" />
      <param name="priority" expr="currentTask.priority" />
    </send>
  </onentry>

  <transition event="task.acknowledged" target="confirmed" />
</state>
```

## Best Practices

1. **Always provide descriptions**: LLMs rely on descriptions to generate correct data
2. **Use specific event names**: `user.message.text` not `message`
3. **Define required fields**: Make required fields explicit in schema
4. **Use enums for limited options**: Constrain values to valid choices
5. **External schemas for reuse**: Define schemas once, reference multiple times
6. **Version your schemas**: Include version info for breaking changes
7. **Document edge cases**: Note special values or formats in descriptions
8. **Validate early**: Use schemas on all external event sources
9. **Test schema coverage**: Ensure all transitions have appropriate schemas
10. **Keep schemas focused**: One schema per event type

## Error Handling

Handle schema validation failures:

```xml
<state id="processing">
  <transition event="user.input"
              event:schema='{"type": "object", "properties": {"message": {"type": "string"}}, "required": ["message"]}'
              target="valid_input" />

  <!-- Catch validation errors -->
  <transition event="error.execution.validation" target="invalid_input">
    <assign location="validationError" expr="_event.data" />
  </transition>
</state>

<state id="invalid_input">
  <onentry>
    <log expr="'Invalid input: ' + validationError.message" />
  </onentry>
  <transition target="awaiting_input" />
</state>
```

## Next Steps

- Learn about [Namespaces](/concepts/namespaces) for extending functionality
- Explore [Token Efficiency](/concepts/token-efficiency) for cost optimization
- Read [Document Structure](/architecture/document-structure) for syntax details
- See [Namespace System](/architecture/namespace-system) for external schema loading
