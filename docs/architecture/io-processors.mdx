---
title: "I/O Processors"
description: "External communication in AgentML via SCXML I/O Processors for HTTP, WebSocket, and distributed systems"
---

# I/O Processors

I/O Processors (IOProcessors) are SCXML's mechanism for communicating with external systems. In AgentML, they enable agents to send and receive events over HTTP, WebSocket, and other protocols, creating distributed multi-agent systems.

## Overview

IOProcessors bridge the gap between state machines and the outside world. They handle:
- Sending events to external systems
- Receiving events from external sources
- Protocol-specific serialization/deserialization
- Connection management
- Error handling

## The `<send>` Element

The `<send>` element sends events to external targets via IOProcessors:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript">

  <state id="notify">
    <onentry>
      <send event="task.completed"
            target="https://api.example.com/webhooks"
            type="github.com/agentflare-ai/agentml/ioprocessor/http">
        <param name="taskId" expr="currentTask.id" />
        <param name="result" expr="currentTask.result" />
      </send>
    </onentry>

    <transition event="task.acknowledged" target="done" />
    <transition event="error.communication" target="retry" />
  </state>
</agent>
```

**Attributes:**
- `event` - Event name to send (required)
- `target` - Destination URI (required for external sends)
- `type` - IOProcessor type (optional, inferred from target)
- `delay` - Delay before sending (optional)
- `id` - Send ID for cancellation (optional)

**Child elements:**
- `<param>` - Event data parameters
- `<content>` - Event data as XML/JSON content

## Built-in IOProcessors

### HTTP IOProcessor

Send events via HTTP POST requests:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript">

  <state id="call_api">
    <onentry>
      <send event="api.request"
            target="https://api.example.com/process"
            type="github.com/agentflare-ai/agentml/ioprocessor/http">
        <param name="query" expr="userInput" />
        <param name="userId" expr="currentUser.id" />
      </send>
    </onentry>

    <!-- Response arrives as event -->
    <transition event="api.response" target="process_response">
      <assign location="apiResult" expr="_event.data" />
    </transition>

    <transition event="error.communication" target="handle_error">
      <assign location="errorDetails" expr="_event.data" />
    </transition>
  </state>
</agent>
```

**HTTP Request Format:**
```http
POST /process HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
  "event": "api.request",
  "data": {
    "query": "user input text",
    "userId": "user123"
  }
}
```

**HTTP Response Format:**
```json
{
  "event": "api.response",
  "data": {
    "result": "processed data"
  }
}
```

### WebSocket IOProcessor

Persistent bidirectional communication:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript">

  <state id="connect">
    <onentry>
      <!-- Connect to WebSocket -->
      <send event="ws.connect"
            target="wss://chat.example.com/room/123"
            type="github.com/agentflare-ai/agentml/ioprocessor/websocket" />
    </onentry>

    <transition event="ws.connected" target="chat">
      <assign location="connected" expr="true" />
    </transition>

    <transition event="error.communication" target="reconnect" />
  </state>

  <state id="chat">
    <onentry>
      <!-- Send message -->
      <send event="chat.message"
            target="wss://chat.example.com/room/123"
            type="github.com/agentflare-ai/agentml/ioprocessor/websocket">
        <param name="text" expr="messageText" />
        <param name="sender" expr="userId" />
      </send>
    </onentry>

    <!-- Receive incoming messages -->
    <transition event="chat.message" target="process_message">
      <assign location="lastMessage" expr="_event.data" />
    </transition>

    <transition event="ws.disconnected" target="reconnect" />
  </state>
</agent>
```

**WebSocket Message Format:**
```json
{
  "event": "chat.message",
  "data": {
    "text": "Hello everyone",
    "sender": "user123"
  }
}
```

### Stdin IOProcessor (Console I/O)

Built into the `stdin` namespace:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       import:stdin="github.com/agentflare-ai/agentml/stdin">

  <state id="read_input">
    <onentry>
      <stdin:write expr="'Bot: What can I help you with?'" />
      <stdin:read location="userInput" />
    </onentry>

    <transition event="stdin.received" target="process">
      <assign location="input" expr="_event.data" />
    </transition>
  </state>
</agent>
```

### Internal IOProcessor

Send to the same agent (internal events):

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript">

  <state id="process">
    <onentry>
      <!-- Send to self -->
      <send event="internal.processed"
            target="#_internal"
            delay="1s">
        <param name="result" expr="processedData" />
      </send>
    </onentry>

    <transition event="internal.processed" target="next_step" />
  </state>
</agent>
```

### SCXML IOProcessor

Send to other AgentML agents:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript">

  <state id="coordinate">
    <onentry>
      <!-- Send to another agent instance -->
      <send event="task.assigned"
            target="#_scxml_session-id-123"
            type="github.com/agentflare-ai/agentml/ioprocessor/scxml">
        <param name="taskId" expr="newTask.id" />
        <param name="priority" expr="'high'" />
      </send>
    </onentry>

    <transition event="task.accepted" target="monitor" />
    <transition event="task.rejected" target="reassign" />
  </state>
</agent>
```

## Multi-Agent Communication

### Distributed Agent System

```xml
<!-- Orchestrator Agent -->
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       name="orchestrator"
       datamodel="ecmascript">

  <datamodel>
    <data id="workers" expr="['http://worker1:8080', 'http://worker2:8080']" />
    <data id="tasks" expr="[]" />
    <data id="results" expr="[]" />
  </datamodel>

  <state id="distribute">
    <onentry>
      <!-- Send tasks to workers -->
      <foreach array="workers" item="worker" index="i">
        <send event="task.process"
              targetexpr="worker + '/agent'"
              type="github.com/agentflare-ai/agentml/ioprocessor/http">
          <param name="taskId" expr="tasks[i].id" />
          <param name="data" expr="tasks[i].data" />
        </send>
      </foreach>
    </onentry>

    <!-- Collect results -->
    <transition event="task.result" target="aggregate">
      <assign location="results" expr="results.concat([_event.data])" />
    </transition>
  </state>

  <state id="aggregate">
    <onentry>
      <if cond="results.length === workers.length">
        <raise event="all.completed" />
      </if>
    </onentry>

    <transition event="all.completed" target="finalize" />
  </state>
</agent>
```

```xml
<!-- Worker Agent -->
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       name="worker"
       datamodel="ecmascript"
       import:gemini="github.com/agentflare-ai/agentml/gemini">

  <state id="idle">
    <!-- Receive tasks from orchestrator -->
    <transition event="task.process" target="processing">
      <assign location="currentTask" expr="_event.data" />
    </transition>
  </state>

  <state id="processing">
    <onentry>
      <gemini:generate
        model="gemini-2.0-flash-exp"
        location="_event"
        promptexpr="'Process: ' + currentTask.data" />
    </onentry>

    <transition event="action.response" target="respond">
      <assign location="result" expr="_event.data.message" />
    </transition>
  </state>

  <state id="respond">
    <onentry>
      <!-- Send result back to orchestrator -->
      <send event="task.result"
            targetexpr="_event.origin"
            type="github.com/agentflare-ai/agentml/ioprocessor/http">
        <param name="taskId" expr="currentTask.taskId" />
        <param name="result" expr="result" />
      </send>
    </onentry>

    <transition target="idle" />
  </state>
</agent>
```

## Event Routing

### Target Resolution

The `target` attribute determines where events are sent:

```xml
<!-- Internal (same agent) -->
<send event="e" target="#_internal" />

<!-- SCXML session (another agent instance) -->
<send event="e" target="#_scxml_abc123" />

<!-- HTTP endpoint -->
<send event="e" target="https://api.example.com/webhook" />

<!-- WebSocket connection -->
<send event="e" target="wss://realtime.example.com/events" />

<!-- Dynamic target from variable -->
<send event="e" targetexpr="apiEndpoint" />
```

### Event Origin

Responses know where they came from via `_event.origin`:

```xml
<state id="request">
  <onentry>
    <send event="api.request" target="https://api.example.com/process" />
  </onentry>

  <transition event="api.response" target="respond">
    <!-- _event.origin = https://api.example.com/process -->
    <log expr="'Response from: ' + _event.origin" />
  </transition>
</state>
```

## Delayed Sends

Send events after a delay:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript">

  <state id="waiting">
    <onentry>
      <!-- Send after 30 seconds -->
      <send event="timeout"
            target="#_internal"
            id="timeout_send"
            delay="30s" />
    </onentry>

    <!-- Can cancel before delay expires -->
    <transition event="user.input" target="process">
      <cancel sendid="timeout_send" />
    </transition>

    <transition event="timeout" target="timed_out" />
  </state>
</agent>
```

**Delay formats:**
- Milliseconds: `1000ms`
- Seconds: `30s`
- Minutes: `5m`
- Hours: `1h`
- Expression: `delayexpr="timeout_duration"`

## Content Types

### Parameter-based (default)

```xml
<send event="api.request" target="https://api.example.com/process">
  <param name="field1" expr="'value1'" />
  <param name="field2" expr="123" />
</send>
```

Sends:
```json
{
  "event": "api.request",
  "data": {
    "field1": "value1",
    "field2": 123
  }
}
```

### Content-based

```xml
<send event="api.request" target="https://api.example.com/process">
  <content expr='{"query": userInput, "options": {"format": "json"}}' />
</send>
```

Or inline:
```xml
<send event="api.request" target="https://api.example.com/process">
  <content>
    {
      "query": "search term",
      "options": {
        "format": "json"
      }
    }
  </content>
</send>
```

## Error Handling

IOProcessors raise error events on failure:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript">

  <state id="send_request">
    <onentry>
      <send event="api.request"
            target="https://api.example.com/process"
            id="api_send">
        <param name="data" expr="requestData" />
      </send>
    </onentry>

    <!-- Communication errors -->
    <transition event="error.communication" target="handle_error">
      <assign location="errorType" expr="'communication'" />
      <assign location="errorDetails" expr="_event.data" />
    </transition>

    <!-- Send-specific errors -->
    <transition event="error.send" target="handle_error">
      <assign location="errorType" expr="'send'" />
    </transition>

    <!-- Timeout -->
    <transition event="timeout" target="retry">
      <assign location="retryCount" expr="retryCount + 1" />
    </transition>

    <transition event="api.response" target="success" />
  </state>

  <state id="handle_error">
    <onentry>
      <log expr="'Error: ' + errorType + ' - ' + JSON.stringify(errorDetails)" />

      <if cond="retryCount < 3">
        <raise event="should.retry" />
      <else/>
        <raise event="should.fail" />
      </if>
    </onentry>

    <transition event="should.retry" target="send_request" />
    <transition event="should.fail" target="failed" />
  </state>
</agent>
```

## Custom IOProcessors

### Go Implementation

```go
package customioprocessor

import (
    "github.com/agentflare-ai/agentmlx/pkg/ioprocessor"
)

type SlackIOProcessor struct {
    apiToken string
}

func NewSlackIOProcessor(token string) *SlackIOProcessor {
    return &SlackIOProcessor{apiToken: token}
}

func (p *SlackIOProcessor) Type() string {
    return "github.com/example/ioprocessor/slack"
}

func (p *SlackIOProcessor) Send(target string, event *ioprocessor.Event) error {
    // Parse target as Slack channel ID
    channelID := target

    // Send message via Slack API
    return p.sendSlackMessage(channelID, event.Name, event.Data)
}

func (p *SlackIOProcessor) Receive(callback func(*ioprocessor.Event)) error {
    // Set up Slack event listener
    // Call callback when events arrive
    return p.listenSlackEvents(callback)
}

func Register(token string) {
    ioprocessor.RegisterIOProcessor(NewSlackIOProcessor(token))
}
```

**Usage:**
```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript">

  <state id="notify_team">
    <onentry>
      <send event="deployment.complete"
            target="C01234567"
            type="github.com/example/ioprocessor/slack">
        <param name="message" expr="'Deployment v' + version + ' completed'" />
        <param name="status" expr="'success'" />
      </send>
    </onentry>
  </state>
</agent>
```

## IOProcessor Patterns

### Request-Response Pattern

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript">

  <datamodel>
    <data id="requestId" expr="''" />
  </datamodel>

  <state id="request">
    <onentry>
      <assign location="requestId" expr="'req_' + Date.now()" />

      <send event="api.request"
            target="https://api.example.com/query">
        <param name="requestId" expr="requestId" />
        <param name="query" expr="userQuery" />
      </send>
    </onentry>

    <!-- Match response by requestId -->
    <transition event="api.response"
                cond="_event.data.requestId === requestId"
                target="process_response">
      <assign location="responseData" expr="_event.data" />
    </transition>

    <transition event="api.response" target="request">
      <!-- Ignore responses for other requests -->
      <log expr="'Ignoring response for different request'" />
    </transition>
  </state>
</agent>
```

### Pub/Sub Pattern

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript">

  <state id="subscribe">
    <onentry>
      <!-- Subscribe to topic -->
      <send event="pubsub.subscribe"
            target="wss://pubsub.example.com/topics/notifications"
            type="github.com/agentflare-ai/agentml/ioprocessor/websocket">
        <param name="topic" expr="'notifications'" />
        <param name="userId" expr="currentUser.id" />
      </send>
    </onentry>

    <transition event="pubsub.subscribed" target="listening" />
  </state>

  <state id="listening">
    <!-- Receive published messages -->
    <transition event="notification.received" target="handle_notification">
      <assign location="notification" expr="_event.data" />
    </transition>
  </state>

  <state id="publish">
    <onentry>
      <!-- Publish to topic -->
      <send event="notification.new"
            target="wss://pubsub.example.com/topics/notifications"
            type="github.com/agentflare-ai/agentml/ioprocessor/websocket">
        <param name="topic" expr="'notifications'" />
        <param name="message" expr="notificationMessage" />
      </send>
    </onentry>
  </state>
</agent>
```

### Webhook Pattern

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       datamodel="ecmascript">

  <!-- Receive webhook events from external services -->
  <state id="webhook_listener">
    <!-- Events arrive from IOProcessor automatically -->
    <transition event="github.push" target="handle_push">
      <assign location="pushData" expr="_event.data" />
    </transition>

    <transition event="stripe.payment_succeeded" target="handle_payment">
      <assign location="paymentData" expr="_event.data" />
    </transition>
  </state>

  <state id="handle_push">
    <onentry>
      <log expr="'Received push to: ' + pushData.repository.full_name" />

      <!-- Trigger CI/CD -->
      <send event="ci.trigger"
            target="https://ci.example.com/build">
        <param name="repo" expr="pushData.repository.full_name" />
        <param name="branch" expr="pushData.ref" />
      </send>
    </onentry>
  </state>
</agent>
```

## Best Practices

1. **Handle errors gracefully**: Always add error transitions for `<send>`
2. **Use request IDs**: Track request-response pairs with unique IDs
3. **Set timeouts**: Don't wait indefinitely for responses
4. **Retry with backoff**: Implement exponential backoff for retries
5. **Validate responses**: Use `event:schema` for response validation
6. **Log communications**: Track all external interactions
7. **Secure endpoints**: Use HTTPS/WSS for production
8. **Rate limit**: Avoid overwhelming external services
9. **Monitor health**: Check IOProcessor connection status
10. **Test isolation**: Mock IOProcessors for unit tests

## Configuration

### HTTP IOProcessor Settings

```bash
# Set HTTP timeout
export AGENTML_HTTP_TIMEOUT=30s

# Set max retries
export AGENTML_HTTP_RETRIES=3

# Set retry backoff
export AGENTML_HTTP_BACKOFF=exponential
```

### WebSocket IOProcessor Settings

```bash
# Set reconnection interval
export AGENTML_WS_RECONNECT_INTERVAL=5s

# Set ping interval
export AGENTML_WS_PING_INTERVAL=30s
```

## Next Steps

- Learn about [Namespace System](/architecture/namespace-system) for extending functionality
- Explore [Interpreter](/architecture/interpreter) to understand event processing
- Read [Document Structure](/architecture/document-structure) for `<send>` syntax
- See [Deployment](/deployment/overview) for distributed agent systems
- Understand [Error Handling](/best-practices/error-handling) for robust communication
