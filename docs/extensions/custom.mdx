---
title: "Custom Extensions"
description: "Build custom AgentML namespaces to extend functionality"
---

# Custom Extensions

Learn how to build custom namespaces to extend AgentML with domain-specific actions and integrations.

## Overview

Custom namespaces allow you to:
- Add new XML actions to AgentML
- Integrate with external APIs and services
- Implement specialized business logic
- Create reusable components

## Extension Structure

A namespace is a Go package that registers custom actions:

```go
package myextension

import (
    "github.com/agentflare-ai/agentmlx/pkg/scxml"
)

// Action struct defines attributes
type MyAction struct {
    Model    string `xml:"model,attr"`
    Location string `xml:"location,attr"`
    Input    string `xml:"inputexpr,attr"`
}

// Execute runs when action is invoked
func (a *MyAction) Execute(ctx *scxml.Context) error {
    // Your logic here
    return nil
}

// Register the namespace
func Register() {
    scxml.RegisterNamespace("github.com/example/myextension", map[string]interface{}{
        "myaction": &MyAction{},
    })
}
```

## Basic Example

Create a simple HTTP request extension:

**httpext/actions.go:**
```go
package httpext

import (
    "encoding/json"
    "io"
    "net/http"
    "github.com/agentflare-ai/agentmlx/pkg/scxml"
)

type FetchAction struct {
    URL      string `xml:"url,attr"`
    Location string `xml:"location,attr"`
}

func (a *FetchAction) Execute(ctx *scxml.Context) error {
    // Make HTTP request
    resp, err := http.Get(a.URL)
    if err != nil {
        ctx.RaiseEvent("http.error", map[string]interface{}{
            "error": err.Error(),
        })
        return nil
    }
    defer resp.Body.Close()

    // Read response
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        ctx.RaiseEvent("http.error", map[string]interface{}{
            "error": err.Error(),
        })
        return nil
    }

    // Parse JSON
    var data interface{}
    json.Unmarshal(body, &data)

    // Store in datamodel
    ctx.SetVariable(a.Location, data)

    // Raise completion event
    ctx.RaiseEvent("http.complete", map[string]interface{}{
        "url": a.URL,
        "data": data,
    })

    return nil
}

func Register() {
    scxml.RegisterNamespace("github.com/example/httpext", map[string]interface{}{
        "fetch": &FetchAction{},
    })
}
```

**Usage:**
```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       import:http="github.com/example/httpext">

  <state id="fetch_data">
    <onentry>
      <http:fetch
        url="https://api.example.com/data"
        location="apiData" />
    </onentry>

    <transition event="http.complete" target="process_data">
      <log expr="'Fetched: ' + JSON.stringify(apiData)" />
    </transition>

    <transition event="http.error" target="handle_error" />
  </state>
</agent>
```

## Expression Evaluation

Evaluate ECMAScript expressions from attributes:

```go
type ComputeAction struct {
    Expression string `xml:"expr,attr"`
    Location   string `xml:"location,attr"`
}

func (a *ComputeAction) Execute(ctx *scxml.Context) error {
    // Evaluate expression
    result := ctx.EvalExpression(a.Expression)

    // Store result
    ctx.SetVariable(a.Location, result)

    return nil
}
```

**Usage:**
```xml
<custom:compute
  expr="count + 10"
  location="newCount" />
```

## Accessing Datamodel

Read and write variables:

```go
func (a *MyAction) Execute(ctx *scxml.Context) error {
    // Get variable
    userInput := ctx.GetVariable("userInput")

    // Process
    result := process(userInput)

    // Set variable
    ctx.SetVariable("result", result)

    return nil
}
```

## Raising Events

Communicate results back to the agent:

```go
func (a *ProcessAction) Execute(ctx *scxml.Context) error {
    // Do work
    result, err := doWork()

    if err != nil {
        // Raise error event
        ctx.RaiseEvent("custom.error", map[string]interface{}{
            "error": err.Error(),
            "code": "PROCESS_FAILED",
        })
        return nil
    }

    // Raise success event
    ctx.RaiseEvent("custom.complete", map[string]interface{}{
        "result": result,
        "timestamp": time.Now().Unix(),
    })

    return nil
}
```

## Advanced Example: Slack Integration

Create a Slack notification extension:

**slackext/actions.go:**
```go
package slackext

import (
    "bytes"
    "encoding/json"
    "net/http"
    "github.com/agentflare-ai/agentmlx/pkg/scxml"
)

type SendMessageAction struct {
    Channel string `xml:"channel,attr"`
    Text    string `xml:"textexpr,attr"`
    Token   string `xml:"token,attr"`
}

func (a *SendMessageAction) Execute(ctx *scxml.Context) error {
    // Evaluate text expression
    text := ctx.EvalExpression(a.Text)

    // Prepare request
    payload := map[string]interface{}{
        "channel": a.Channel,
        "text":    text,
    }

    body, _ := json.Marshal(payload)

    // Send to Slack API
    req, _ := http.NewRequest("POST", "https://slack.com/api/chat.postMessage", bytes.NewBuffer(body))
    req.Header.Set("Authorization", "Bearer "+a.Token)
    req.Header.Set("Content-Type", "application/json")

    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        ctx.RaiseEvent("slack.error", map[string]interface{}{
            "error": err.Error(),
        })
        return nil
    }
    defer resp.Body.Close()

    // Parse response
    var result map[string]interface{}
    json.NewDecoder(resp.Body).Decode(&result)

    if ok, _ := result["ok"].(bool); ok {
        ctx.RaiseEvent("slack.sent", map[string]interface{}{
            "channel": a.Channel,
            "ts":      result["ts"],
        })
    } else {
        ctx.RaiseEvent("slack.error", map[string]interface{}{
            "error": result["error"],
        })
    }

    return nil
}

func Register() {
    scxml.RegisterNamespace("github.com/example/slack", map[string]interface{}{
        "send": &SendMessageAction{},
    })
}
```

**Usage:**
```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       import:slack="github.com/example/slack">

  <datamodel>
    <data id="slackToken" expr="'xoxb-your-token'" />
  </datamodel>

  <state id="notify_team">
    <onentry>
      <slack:send
        channel="#deployments"
        textexpr="'Deployment v' + version + ' completed successfully'"
        token="slackToken" />
    </onentry>

    <transition event="slack.sent" target="complete">
      <log expr="'Notification sent to Slack'" />
    </transition>

    <transition event="slack.error" target="notification_failed" />
  </state>
</agent>
```

## Async Operations

Handle long-running operations:

```go
type LongProcessAction struct {
    Data     string `xml:"dataexpr,attr"`
    Location string `xml:"location,attr"`
}

func (a *LongProcessAction) Execute(ctx *scxml.Context) error {
    data := ctx.EvalExpression(a.Data)

    // Start async operation
    go func() {
        // Do long-running work
        result := processAsync(data)

        // Raise event when complete
        ctx.RaiseEvent("async.complete", map[string]interface{}{
            "result": result,
        })
    }()

    // Return immediately
    ctx.RaiseEvent("async.started", nil)
    return nil
}
```

## Error Handling

Always handle errors gracefully:

```go
func (a *MyAction) Execute(ctx *scxml.Context) error {
    // Validate inputs
    if a.Required == "" {
        ctx.RaiseEvent("error.execution", map[string]interface{}{
            "error": "Required attribute is missing",
            "action": "myaction",
        })
        return nil
    }

    // Try operation
    result, err := tryOperation()
    if err != nil {
        ctx.RaiseEvent("myext.error", map[string]interface{}{
            "error": err.Error(),
            "recoverable": true,
        })
        return nil
    }

    // Success
    ctx.RaiseEvent("myext.success", map[string]interface{}{
        "result": result,
    })

    return nil
}
```

## Configuration via Environment

Use environment variables for configuration:

```go
import "os"

type APIAction struct {
    Endpoint string `xml:"endpoint,attr"`
    Location string `xml:"location,attr"`
}

func (a *APIAction) Execute(ctx *scxml.Context) error {
    // Get API key from environment
    apiKey := os.Getenv("MY_API_KEY")
    if apiKey == "" {
        ctx.RaiseEvent("error.execution", map[string]interface{}{
            "error": "MY_API_KEY environment variable not set",
        })
        return nil
    }

    // Use API key
    result := callAPI(a.Endpoint, apiKey)
    ctx.SetVariable(a.Location, result)

    return nil
}
```

## Testing Extensions

Write tests for your actions:

```go
package myextension_test

import (
    "testing"
    "github.com/agentflare-ai/agentmlx/pkg/scxml"
    "myextension"
)

func TestMyAction(t *testing.T) {
    // Create test context
    ctx := scxml.NewTestContext()
    ctx.SetVariable("input", "test data")

    // Create action
    action := &myextension.MyAction{
        Input:    "input",
        Location: "output",
    }

    // Execute
    err := action.Execute(ctx)
    if err != nil {
        t.Fatalf("Action failed: %v", err)
    }

    // Verify result
    output := ctx.GetVariable("output")
    if output != "expected result" {
        t.Errorf("Expected 'expected result', got %v", output)
    }

    // Verify events
    events := ctx.GetRaisedEvents()
    if len(events) != 1 || events[0].Name != "myext.complete" {
        t.Error("Expected myext.complete event")
    }
}
```

## Best Practices

1. **Namespace URIs**: Use descriptive, versioned URIs (e.g., `github.com/org/project/v1`)
2. **Error handling**: Always raise events for errors, never panic
3. **Expression evaluation**: Use `ctx.EvalExpression()` for dynamic values
4. **Event naming**: Follow dot-separated convention (`namespace.action.status`)
5. **Documentation**: Provide clear docs with examples
6. **Testing**: Write comprehensive unit tests
7. **Dependencies**: Minimize external dependencies
8. **Configuration**: Use environment variables for secrets
9. **Async operations**: Return immediately, raise events when done
10. **Validation**: Validate inputs before processing

## WASM Extensions (Future)

Future support for WebAssembly extensions:

```rust
// Rust implementation with wit-bindgen
use wit_bindgen::generate;

generate!({
    path: "agentml.wit",
});

struct MyExtension;

impl Namespace for MyExtension {
    fn execute_action(params: ActionParams) -> ActionResult {
        // Process action
        ActionResult {
            success: true,
            events: vec![("custom.complete", "result")],
            datamodel_updates: vec![],
            error: None,
        }
    }
}
```

Load WASM extensions via URL:

```xml
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       import:custom="https://cdn.example.com/extension.wasm">

  <state id="use_wasm">
    <onentry>
      <custom:action param="value" />
    </onentry>
  </state>
</agent>
```

## Publishing Extensions

Share your extension:

1. **Create repository**: Host on GitHub/GitLab
2. **Document thoroughly**: README with examples
3. **Version properly**: Use semantic versioning
4. **Tag releases**: Git tags for versions
5. **Provide examples**: Sample agents using your extension
6. **Test extensively**: CI/CD with tests
7. **License clearly**: Choose open-source license

## Next Steps

- Review [Gemini Extension](/extensions/gemini) source code for examples
- Explore [Ollama Extension](/extensions/ollama) implementation patterns
- Study [Memory Extension](/extensions/memory) for complex integrations
- Read [Namespace System](/architecture/namespace-system) for technical details
- See [Contributing](/contributing/guidelines) for contribution guidelines
