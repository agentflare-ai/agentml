---
title: "Memory Extension"
description: "Add vector search and graph database capabilities to AgentML agents with sqlite-graph"
---

# Memory Extension

The Memory namespace (`github.com/agentflare-ai/agentml-go/memory`) provides persistent storage, vector embeddings, similarity search, and graph database capabilities powered by `sqlite-graph` - all in a single SQLite file.

## Features

- **Vector embeddings**: Generate embeddings for semantic search
- **Similarity search**: Find similar content using vector distance
- **Graph database**: Store and query relationships with Cypher
- **Key-value storage**: Simple persistent data storage
- **All in SQLite**: Single file, no external dependencies

## Basic Usage

```xml
<agent xmlns="github.com/agentflare-ai/agentml"
       datamodel="ecmascript"
       xmlns:memory="github.com/agentflare-ai/agentml-go/memory">

  <state id="store">
    <onentry>
      <!-- Store key-value data -->
      <memory:put key="user_name" expr="'Alice'" />

      <!-- Generate and store embedding -->
      <memory:embed location="embedding" expr="textContent" />
    </onentry>

    <transition target="search" />
  </state>

  <state id="search">
    <onentry>
      <!-- Search by similarity -->
      <memory:search location="results" expr="queryEmbedding" limit="5" />
    </onentry>

    <transition target="process_results" />
  </state>
</agent>
```

## Actions

### `<memory:put>`

Store key-value data:

```xml
<memory:put key="preference" expr="userPreference" />
<memory:put key="last_query" expr="userQuery" />
<memory:put key="session_data" expr='{"user": "alice", "timestamp": Date.now()}' />
```

### `<memory:get>`

Retrieve stored data:

```xml
<memory:get key="preference" location="userPreference" />
<memory:get key="session_data" location="session" />
```

### `<memory:embed>`

Generate vector embeddings:

```xml
<memory:embed location="embedding" expr="textContent" />
<memory:embed location="queryVector" expr="userQuery" />
```

### `<memory:search>`

Vector similarity search:

```xml
<!-- Search for similar content -->
<memory:search location="results" expr="queryEmbedding" limit="10" />

<!-- Results stored in location variable -->
<!-- _event.data.results = [{content, similarity, metadata}, ...] -->
```

### `<memory:graph-query>`

Query graph database with Cypher:

```xml
<memory:graph-query location="results">
  <query>
    MATCH (p:Person)-[:KNOWS]->(friend:Person)
    WHERE p.age > 25
    RETURN p.name, friend.name, friend.age
  </query>
</memory:graph-query>
```

## Memory-Augmented Generation

Combine memory with LLM for context-aware responses:

```xml
<agent xmlns="github.com/agentflare-ai/agentml"
       datamodel="ecmascript"
       xmlns:gemini="github.com/agentflare-ai/agentml/gemini"
       xmlns:memory="github.com/agentflare-ai/agentml-go/memory">

  <datamodel>
    <data id="userQuery" expr="''" />
    <data id="context" expr="[]" />
    <data id="response" expr="''" />
  </datamodel>

  <state id="search_context">
    <onentry>
      <!-- Generate query embedding -->
      <memory:embed location="queryEmbedding" expr="userQuery" />

      <!-- Search for relevant context -->
      <memory:search location="searchResults" expr="queryEmbedding" limit="3" />

      <!-- Extract context -->
      <assign location="context" expr="searchResults.map(r => r.content)" />
    </onentry>

    <transition target="generate" />
  </state>

  <state id="generate">
    <onentry>
      <!-- Generate with context -->
      <gemini:generate
        model="gemini-2.0-flash-exp"
        location="_event"
        promptexpr="'Context:\n' + context.join('\n\n') + '\n\nQuestion: ' + userQuery" />
    </onentry>

    <transition event="action.response" target="store_response">
      <assign location="response" expr="_event.data.message" />
    </transition>
  </state>

  <state id="store_response">
    <onentry>
      <!-- Store response for future searches -->
      <memory:embed location="responseEmbedding" expr="userQuery + ' ' + response" />

      <!-- Store with metadata -->
      <memory:put
        key="'qa_' + Date.now()"
        expr='{"query": userQuery, "response": response, "embedding": responseEmbedding}' />
    </onentry>

    <transition target="complete" />
  </state>
</agent>
```

## Graph Database

Model relationships with graph queries:

```xml
<agent xmlns="github.com/agentflare-ai/agentml"
       datamodel="ecmascript"
       xmlns:memory="github.com/agentflare-ai/agentml-go/memory">

  <state id="query_relationships">
    <onentry>
      <!-- Find friends of friends -->
      <memory:graph-query location="friends_of_friends">
        <query>
          MATCH (me:Person {name: 'Alice'})-[:KNOWS]->(friend)-[:KNOWS]->(fof)
          WHERE NOT (me)-[:KNOWS]->(fof)
          RETURN DISTINCT fof.name AS suggestion, COUNT(friend) AS mutualFriends
          ORDER BY mutualFriends DESC
          LIMIT 5
        </query>
      </memory:graph-query>

      <!-- Find common interests -->
      <memory:graph-query location="common_interests">
        <query>
          MATCH (me:Person {name: 'Alice'})-[:LIKES]->(interest)<-[:LIKES]-(other:Person)
          WHERE me <> other
          RETURN other.name, COLLECT(interest.name) AS sharedInterests
        </query>
      </memory:graph-query>
    </onentry>

    <transition target="process_results" />
  </state>

  <state id="create_relationships">
    <onentry>
      <!-- Create nodes and relationships -->
      <memory:graph-query location="result">
        <query>
          CREATE (alice:Person {name: 'Alice', age: 30})
          CREATE (bob:Person {name: 'Bob', age: 25})
          CREATE (alice)-[:KNOWS]->(bob)
          RETURN alice, bob
        </query>
      </memory:graph-query>
    </onentry>

    <transition target="complete" />
  </state>
</agent>
```

## Semantic Search Example

Build a semantic search agent:

```xml
<agent xmlns="github.com/agentflare-ai/agentml"
       datamodel="ecmascript"
       xmlns:memory="github.com/agentflare-ai/agentml-go/memory"
       xmlns:stdin="github.com/agentflare-ai/agentml-go/stdin">

  <state id="index_documents">
    <onentry>
      <!-- Index documents with embeddings -->
      <foreach array="documents" item="doc" index="i">
        <memory:embed location="embedding" expr="doc.content" />
        <memory:put
          key="'doc_' + i"
          expr='{"content": doc.content, "title": doc.title, "embedding": embedding}' />
      </foreach>
    </onentry>

    <transition target="search_prompt" />
  </state>

  <state id="search_prompt">
    <onentry>
      <stdin:write expr="'Enter search query:'" />
      <stdin:read location="query" />
    </onentry>

    <transition event="stdin.received" target="search" />
  </state>

  <state id="search">
    <onentry>
      <!-- Generate query embedding -->
      <memory:embed location="queryEmbedding" expr="query" />

      <!-- Search similar documents -->
      <memory:search location="results" expr="queryEmbedding" limit="5" />
    </onentry>

    <transition target="display_results" />
  </state>

  <state id="display_results">
    <onentry>
      <stdin:write expr="'Top results:\n' + results.map((r, i) => (i+1) + '. ' + r.title + ' (similarity: ' + r.similarity + ')').join('\n')" />
    </onentry>

    <transition target="search_prompt" />
  </state>
</agent>
```

## Configuration

```bash
# Set memory database path (optional)
export AGENTML_MEMORY_DB=/path/to/memory.db

# Use default (./memory.db in current directory)
agentmlx run agent.aml
```

## Best Practices

1. **Index strategically**: Generate embeddings for searchable content
2. **Use metadata**: Store additional information with embeddings
3. **Limit search results**: Use appropriate `limit` values
4. **Clean old data**: Periodically remove outdated entries
5. **Optimize queries**: Use indexed fields in graph queries
6. **Batch operations**: Group multiple puts/gets when possible
7. **Test similarity**: Validate search relevance with sample queries
8. **Monitor size**: Track database file size growth
9. **Backup regularly**: SQLite files are easily backed up
10. **Use transactions**: Group related operations for consistency

## SQLite File

All memory data is stored in a single SQLite file:

```bash
# View database
sqlite3 memory.db ".tables"

# Backup database
cp memory.db memory.backup.db

# Reset database
rm memory.db
```

## Next Steps

- Learn about [Gemini Extension](/extensions/gemini) for LLM-powered search
- Explore [Ollama Extension](/extensions/ollama) for local embeddings
- Read [Token Efficiency](/concepts/token-efficiency) for optimizing context
- See [Best Practices](/best-practices/performance) for production tips
