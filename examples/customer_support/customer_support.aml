<?xml version="1.0" encoding="UTF-8"?>
<agent xmlns="github.com/agentflare-ai/agentml/agent"
       version="1.0"
       datamodel="ecmascript"
       initial="initialize"
       xmlns:use="github.com/agentflare-ai/agentml/use"
       xmlns:events="./schemas/events.json"
       xmlns:memory="github.com/agentflare-ai/agentml/memory"
       xmlns:gemini="github.com/agentflare-ai/agentml/gemini"
       xmlns:stdin="github.com/agentflare-ai/agentml/stdin"
       xmlns:env="github.com/agentflare-ai/agentml/env"
       use:events="./schemas/events.json"
       use:memory="github.com/agentflare-ai/agentml/memory"
       use:gemini="github.com/agentflare-ai/agentml/gemini"
       use:stdin="github.com/agentflare-ai/agentml/stdin"
       use:env="github.com/agentflare-ai/agentml/env">

  <!--
    Customer Support Orchestrator for Airlines (Part 4: Specialized Workflows)

    This agent demonstrates proper SCXML decomposition using invoked services.
    Instead of one monolithic file with compound states, we use separate .aml files
    for each specialist, connected via <invoke>.

    Architecture (following README.md Section 5: Decomposition Through Invoked Services):

    Main Orchestrator (this file):
    - Routes user intents to appropriate specialists
    - Manages conversation loop
    - Handles service invocation and responses

    Specialist Services (specialists/*.aml):
    - flight_specialist.aml - Flight search, booking, updates, cancellations
    - hotel_specialist.aml - Hotel search and reservations
    - car_specialist.aml - Car rental search and bookings
    - excursion_specialist.aml - Activity and tour bookings
    - policy_specialist.aml - Policy lookups via vector search
    - general_specialist.aml - General conversational queries

    Benefits of this decomposition:
    - Reusability: Each specialist can be used in other agents
    - Maintainability: Smaller, focused files (~150-200 lines each)
    - Testing: Test specialists in isolation
    - Composition: Build complex agents from simple components
    - Team collaboration: Multiple developers can work independently

    Event Flow:
    1. User input → primary_assistant (intent classification)
    2. Intent → <invoke> appropriate specialist service
    3. Specialist processes request and returns via done.invoke.*
    4. Display response and return to conversation loop
  -->

  <datamodel>
    <data id="conversation_history" expr="[]" />
    <data id="current_user_message" expr="''" />
    <data id="llm_response" expr="''" />
    <data id="passenger_id" expr="'3442 587242'" />
    <data id="db_path" expr="'travel2.sqlite'" />
    <data id="user_flight_info" expr="''" />
    <data id="error_context" expr="''" />
    <data id="gemini_api_key" expr="''" />
  </datamodel>

  <!-- Initial State: Setup and Welcome -->
  <state id="initialize">
    <onentry>
      <log label="SYSTEM" expr="'Customer Support Bot Starting...'" />

      <!-- Check for GEMINI_API_KEY environment variable -->
      <env:get name="GEMINI_API_KEY" location="gemini_api_key" />
      <log label="SYSTEM" expr="'Checking for GEMINI_API_KEY: ' + (gemini_api_key ? 'Found' : 'Not found')" />

      <!-- Raise event to trigger transitions -->
      <raise event="check.complete" />
    </onentry>

    <!-- If API key is not set, request it from user -->
    <transition event="check.complete" cond="!gemini_api_key || gemini_api_key === ''" target="request_api_key" />

    <!-- If API key is set, proceed with initialization -->
    <transition event="check.complete" cond="gemini_api_key &amp;&amp; gemini_api_key !== ''" target="setup_services" />
  </state>

  <!-- Request API Key from User -->
  <state id="request_api_key">
    <onentry>
      <log label="SYSTEM" expr="'GEMINI_API_KEY not found in environment'" />
      <log label="BOT" expr="'GEMINI_API_KEY is not set. Please enter your Gemini API key:'" />

      <!-- Read API key from user -->
      <stdin:read location="gemini_api_key" prompt="API Key: " />

      <!-- Validate and store the API key in environment -->
      <if cond="gemini_api_key &amp;&amp; gemini_api_key.trim() !== ''">
        <env:set name="GEMINI_API_KEY" expr="gemini_api_key" />
        <log label="SYSTEM" expr="'GEMINI_API_KEY has been set'" />
        <raise event="api.key.set" />
      <else/>
        <log label="BOT" expr="'API key cannot be empty. Please try again.'" />
        <raise event="api.key.empty" />
      </if>
    </onentry>

    <!-- If API key was set, proceed -->
    <transition event="api.key.set" target="setup_services" />

    <!-- If API key was empty, ask again -->
    <transition event="api.key.empty" target="request_api_key" />
  </state>

  <!-- Setup Services -->
  <state id="setup_services">
    <onentry>
      <!-- Initialize memory with SQLite database -->
      <memory:init dbpath="travel2.sqlite" />

      <log label="SYSTEM" expr="'Initialized memory with database: ' + db_path" />

      <!-- Fetch user flight information upfront (Part 2-4 pattern) -->
      <memory:get key="user_flight_info_3442_587242" location="user_flight_info" />
      <log label="SYSTEM" expr="'Loaded user flight info: ' + (user_flight_info ? 'Found' : 'None')" />

      <!-- Welcome message -->
      <assign location="llm_response" expr="'Welcome to Swiss Airlines Customer Support! I can help you with flight bookings, hotels, car rentals, excursions, and answer policy questions. How can I assist you today?'" />

      <log label="BOT" expr="llm_response" />
    </onentry>

    <transition target="conversation_loop" />
  </state>

  <!-- Main Conversation Loop -->
  <state id="conversation_loop" initial="await_user_input">

    <!-- Await User Input -->
    <state id="await_user_input">
      <onentry>
        <log label="SYSTEM" expr="'Waiting for user input...'" />

        <!-- Read from stdin -->
        <stdin:read location="current_user_message" prompt="You: " />

        <!-- Add to conversation history -->
        <script><![CDATA[
          conversation_history.push({
            role: 'user',
            content: current_user_message
          });
        ]]></script>

        <log label="USER" expr="'' + current_user_message" />
      </onentry>

      <!-- Check if user wants to exit -->
      <transition cond="current_user_message.toLowerCase().match(/^(exit|quit|bye|goodbye)$/)"
                  target="farewell" />

      <!-- Otherwise, classify intent -->
      <transition target="classify_intent" />
    </state>

    <!-- Classify Intent -->
    <state id="classify_intent">
      <onentry>
        <log label="SYSTEM" expr="'Classifying user intent...'" />

        <!-- Use LLM to classify intent and raise appropriate event -->
        <gemini:generate
          model="gemini-2.0-flash-exp"
          location="_event"
          promptexpr="'Classify user intent: ' + current_user_message" />

        <log label="SYSTEM" expr="'Generated event: ' + JSON.stringify(_event)" />
      </onentry>

      <!-- Route to specialists via invoke based on classified intent -->
      <transition event="intent.flight"
                  event:schema="events:#/components/schemas/FlightIntent"
                  target="invoke_flight_specialist" />

      <transition event="intent.hotel"
                  event:schema="events:#/components/schemas/HotelIntent"
                  target="invoke_hotel_specialist" />

      <transition event="intent.car"
                  event:schema="events:#/components/schemas/CarIntent"
                  target="invoke_car_specialist" />

      <transition event="intent.excursion"
                  event:schema="events:#/components/schemas/ExcursionIntent"
                  target="invoke_excursion_specialist" />

      <transition event="intent.policy"
                  event:schema="events:#/components/schemas/PolicyIntent"
                  target="invoke_policy_specialist" />

      <transition event="intent.general"
                  event:schema="events:#/components/schemas/GeneralIntent"
                  target="invoke_general_specialist" />

      <!-- Direct response (simple queries handled by primary) -->
      <transition event="action.response"
                  event:schema="events:#/components/schemas/ActionResponse"
                  target="display_response" />

      <!-- Fallback: handle errors -->
      <transition event="error.platform" target="handle_error">
        <log label="SYSTEM" expr="'LLM error occurred'" />
      </transition>
    </state>

    <!-- Invoke Flight Specialist -->
    <state id="invoke_flight_specialist">
      <invoke type="scxml" id="flight" src="./specialists/flight_specialist.aml">
        <param name="user_message" expr="current_user_message" />
        <param name="passenger_id" expr="passenger_id" />
      </invoke>

      <!-- Handle completion -->
      <transition event="done.invoke.flight" target="display_response">
        <assign location="llm_response" expr="_event.data.response" />
      </transition>

      <!-- Handle errors -->
      <transition event="error.invoke.flight" target="handle_error">
        <script><![CDATA[
          error_context = 'flight request: ' + (_event.data || 'unknown error');
        ]]></script>
      </transition>
    </state>

    <!-- Invoke Hotel Specialist -->
    <state id="invoke_hotel_specialist">
      <invoke type="scxml" id="hotel" src="./specialists/hotel_specialist.aml">
        <param name="user_message" expr="current_user_message" />
        <param name="passenger_id" expr="passenger_id" />
      </invoke>

      <transition event="done.invoke.hotel" target="display_response">
        <assign location="llm_response" expr="_event.data.response" />
      </transition>

      <transition event="error.invoke.hotel" target="handle_error">
        <script><![CDATA[
          error_context = 'hotel request: ' + (_event.data || 'unknown error');
        ]]></script>
      </transition>
    </state>

    <!-- Invoke Car Specialist -->
    <state id="invoke_car_specialist">
      <invoke type="scxml" id="car" src="./specialists/car_specialist.aml">
        <param name="user_message" expr="current_user_message" />
        <param name="passenger_id" expr="passenger_id" />
      </invoke>

      <transition event="done.invoke.car" target="display_response">
        <assign location="llm_response" expr="_event.data.response" />
      </transition>

      <transition event="error.invoke.car" target="handle_error">
        <script><![CDATA[
          error_context = 'car rental request: ' + (_event.data || 'unknown error');
        ]]></script>
      </transition>
    </state>

    <!-- Invoke Excursion Specialist -->
    <state id="invoke_excursion_specialist">
      <invoke type="scxml" id="excursion" src="./specialists/excursion_specialist.aml">
        <param name="user_message" expr="current_user_message" />
        <param name="passenger_id" expr="passenger_id" />
      </invoke>

      <transition event="done.invoke.excursion" target="display_response">
        <assign location="llm_response" expr="_event.data.response" />
      </transition>

      <transition event="error.invoke.excursion" target="handle_error">
        <script><![CDATA[
          error_context = 'excursion request: ' + (_event.data || 'unknown error');
        ]]></script>
      </transition>
    </state>

    <!-- Invoke Policy Specialist -->
    <state id="invoke_policy_specialist">
      <invoke type="scxml" id="policy" src="./specialists/policy_specialist.aml">
        <param name="user_message" expr="current_user_message" />
      </invoke>

      <transition event="done.invoke.policy" target="display_response">
        <assign location="llm_response" expr="_event.data.response" />
      </transition>

      <transition event="error.invoke.policy" target="handle_error">
        <script><![CDATA[
          error_context = 'policy lookup: ' + (_event.data || 'unknown error');
        ]]></script>
      </transition>
    </state>

    <!-- Invoke General Specialist -->
    <state id="invoke_general_specialist">
      <invoke type="scxml" id="general" src="./specialists/general_specialist.aml">
        <param name="user_message" expr="current_user_message" />
      </invoke>

      <transition event="done.invoke.general" target="display_response">
        <assign location="llm_response" expr="_event.data.response" />
      </transition>

      <transition event="error.invoke.general" target="handle_error">
        <script><![CDATA[
          error_context = 'general request: ' + (_event.data || 'unknown error');
        ]]></script>
      </transition>
    </state>

    <!-- Display Response to User -->
    <state id="display_response">
      <onentry>
        <log label="SYSTEM" expr="'Sending response to user...'" />

        <!-- Handle event.data.message if it exists (direct response from primary) -->
        <script><![CDATA[
          if (_event && _event.data && _event.data.message) {
            llm_response = _event.data.message;
          }
        ]]></script>

        <script><![CDATA[
          conversation_history.push({
            role: 'assistant',
            content: llm_response
          });
        ]]></script>

        <log label="BOT" expr="llm_response" />
      </onentry>

      <transition target="await_user_input" />
    </state>

    <!-- Handle Errors -->
    <state id="handle_error">
      <onentry>
        <log label="SYSTEM" expr="'Error occurred: ' + error_context" />

        <!-- Use Lite model to generate contextual error message -->
        <gemini:generate
          model="gemini-2.5-flash-lite"
          location="_event"
          promptexpr="'Generate friendly error message for: ' + error_context" />

        <assign location="llm_response" expr="_event.data.message" />

        <script><![CDATA[
          conversation_history.push({
            role: 'assistant',
            content: llm_response
          });
        ]]></script>

        <log label="BOT" expr="llm_response" />
      </onentry>

      <transition target="await_user_input" />
    </state>

  </state>

  <!-- Farewell State -->
  <state id="farewell">
    <onentry>
      <log label="SYSTEM" expr="'User ending conversation'" />

      <assign location="llm_response" expr="'Thank you for using Swiss Airlines customer support! Have a great day and safe travels!'" />

      <log label="BOT" expr="llm_response" />
    </onentry>

    <transition target="end" />
  </state>

  <!-- Final State -->
  <final id="end" />

</agent>
